
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>config: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">stripe-service/config/config.go (100.0%)</option>
				
				<option value="file1">stripe-service/internal/handlers/stripe.go (97.2%)</option>
				
				<option value="file2">stripe-service/internal/server/server.go (0.0%)</option>
				
				<option value="file3">stripe-service/internal/service/stripe.go (22.3%)</option>
				
				<option value="file4">stripe-service/main.go (0.0%)</option>
				
				<option value="file5">stripe-service/scripts/create_test_data.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package config

import (
        "os"
        "strconv"
)

// Config holds all configuration for the application
type Config struct {
        Server ServerConfig
        Stripe StripeConfig
}

// ServerConfig holds server-related configuration
type ServerConfig struct {
        Port int
        Host string
}

// StripeConfig holds Stripe-related configuration
type StripeConfig struct {
        SecretKey      string
        PublishableKey string
        WebhookSecret  string
}

// Load loads configuration from environment variables
func Load() *Config <span class="cov8" title="1">{
        config := &amp;Config{
                Server: ServerConfig{
                        Port: getEnvAsInt("PORT", 8080),
                        Host: getEnv("HOST", "localhost"),
                },
                Stripe: StripeConfig{
                        SecretKey:      getEnv("STRIPE_SECRET_KEY", ""),
                        PublishableKey: getEnv("STRIPE_PUBLISHABLE_KEY", ""),
                        WebhookSecret:  getEnv("STRIPE_WEBHOOK_SECRET", ""),
                },
        }

        return config
}</span>

// getEnv gets an environment variable or returns a default value
func getEnv(key, defaultValue string) string <span class="cov8" title="1">{
        if value := os.Getenv(key); value != "" </span><span class="cov8" title="1">{
                return value
        }</span>
        <span class="cov8" title="1">return defaultValue</span>
}

// getEnvAsInt gets an environment variable as integer or returns a default value
func getEnvAsInt(key string, defaultValue int) int <span class="cov8" title="1">{
        if value := os.Getenv(key); value != "" </span><span class="cov8" title="1">{
                if intValue, err := strconv.Atoi(value); err == nil </span><span class="cov8" title="1">{
                        return intValue
                }</span>
        }
        <span class="cov8" title="1">return defaultValue</span>
} </pre>
		
		<pre class="file" id="file1" style="display: none">package handlers

import (
        "encoding/json"
        "fmt"
        "log"
        "net/http"
        "strconv"

        "stripe-service/internal/models"
        "stripe-service/internal/service"

        "github.com/go-playground/validator/v10"
        "github.com/gorilla/mux"
)

// StripeHandler handles HTTP requests for Stripe operations
type StripeHandler struct {
        stripeService service.StripeServiceInterface
        validator     *validator.Validate
}

// NewStripeHandler creates a new Stripe handler
func NewStripeHandler(stripeService service.StripeServiceInterface) *StripeHandler <span class="cov8" title="1">{
        return &amp;StripeHandler{
                stripeService: stripeService,
                validator:     validator.New(),
        }
}</span>

// Helper methods for common operations

// handleServiceError provides consistent error handling for service operations
func (h *StripeHandler) handleServiceError(w http.ResponseWriter, err error, operation string, details map[string]interface{}) <span class="cov8" title="1">{
        // Structured logging with context
        logFields := map[string]interface{}{
                "operation": operation,
                "error":     err.Error(),
        }

        // Add additional details if provided
        for key, value := range details </span><span class="cov8" title="1">{
                logFields[key] = value
        }</span>

        <span class="cov8" title="1">log.Printf("Service error - Operation: %s, Error: %v, Details: %+v", operation, err, details)
        h.writeError(w, http.StatusInternalServerError, fmt.Sprintf("Failed to %s", operation))</span>
}

// parseAndValidateJSON handles JSON parsing and validation
func (h *StripeHandler) parseAndValidateJSON(w http.ResponseWriter, r *http.Request, req interface{}) bool <span class="cov8" title="1">{
        if err := json.NewDecoder(r.Body).Decode(req); err != nil </span><span class="cov8" title="1">{
                h.writeError(w, http.StatusBadRequest, "Invalid JSON format")
                return false
        }</span>

        <span class="cov8" title="1">if err := h.validator.Struct(req); err != nil </span><span class="cov8" title="1">{
                h.writeError(w, http.StatusBadRequest, fmt.Sprintf("Validation error: %v", err))
                return false
        }</span>

        <span class="cov8" title="1">return true</span>
}

// extractPathParameter extracts and validates path parameters
func (h *StripeHandler) extractPathParameter(w http.ResponseWriter, r *http.Request, paramName string) (string, bool) <span class="cov8" title="1">{
        vars := mux.Vars(r)
        value := vars[paramName]

        if value == "" </span><span class="cov8" title="1">{
                h.writeError(w, http.StatusBadRequest, fmt.Sprintf("Missing or empty %s parameter", paramName))
                return "", false
        }</span>

        <span class="cov8" title="1">return value, true</span>
}

// HealthCheck handles health check requests
func (h *StripeHandler) HealthCheck(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        response := map[string]string{
                "status":  "healthy",
                "service": "stripe-service",
        }

        h.writeJSON(w, http.StatusOK, response)
}</span>

// Customer handlers

// CreateCustomer handles customer creation requests
func (h *StripeHandler) CreateCustomer(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var req models.CreateCustomerRequest

        if !h.parseAndValidateJSON(w, r, &amp;req) </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">customer, err := h.stripeService.CreateCustomer(r.Context(), &amp;req)
        if err != nil </span><span class="cov8" title="1">{
                h.handleServiceError(w, err, "create customer", map[string]interface{}{
                        "email": req.Email,
                        "name":  req.Name,
                })
                return
        }</span>

        <span class="cov8" title="1">h.writeJSON(w, http.StatusCreated, customer)</span>
}

// GetCustomer handles customer retrieval requests
func (h *StripeHandler) GetCustomer(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        customerID, ok := h.extractPathParameter(w, r, "id")
        if !ok </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">customer, err := h.stripeService.GetCustomer(r.Context(), customerID)
        if err != nil </span><span class="cov8" title="1">{
                h.handleServiceError(w, err, "get customer", map[string]interface{}{
                        "customer_id": customerID,
                })
                return
        }</span>

        <span class="cov8" title="1">h.writeJSON(w, http.StatusOK, customer)</span>
}

// ListCustomers handles customer listing requests
func (h *StripeHandler) ListCustomers(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        req := &amp;models.ListCustomersRequest{}

        // Parse optional query parameters
        if limitStr := r.URL.Query().Get("limit"); limitStr != "" </span><span class="cov8" title="1">{
                if limit, err := strconv.ParseInt(limitStr, 10, 64); err == nil </span><span class="cov8" title="1">{
                        req.Limit = limit
                }</span>
        }

        <span class="cov8" title="1">if cursor := r.URL.Query().Get("cursor"); cursor != "" </span><span class="cov0" title="0">{
                req.Cursor = cursor
        }</span>

        <span class="cov8" title="1">customers, err := h.stripeService.ListCustomers(r.Context(), req)
        if err != nil </span><span class="cov8" title="1">{
                h.handleServiceError(w, err, "list customers", map[string]interface{}{
                        "limit":  req.Limit,
                        "cursor": req.Cursor,
                })
                return
        }</span>

        <span class="cov8" title="1">h.writeJSON(w, http.StatusOK, customers)</span>
}

// Payment handlers

// CreatePaymentIntent handles payment intent creation requests
func (h *StripeHandler) CreatePaymentIntent(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var req models.CreatePaymentIntentRequest

        if !h.parseAndValidateJSON(w, r, &amp;req) </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">paymentIntent, err := h.stripeService.CreatePaymentIntent(r.Context(), &amp;req)
        if err != nil </span><span class="cov8" title="1">{
                h.handleServiceError(w, err, "create payment intent", map[string]interface{}{
                        "amount":      req.Amount,
                        "currency":    req.Currency,
                        "customer_id": req.CustomerID,
                })
                return
        }</span>

        <span class="cov8" title="1">h.writeJSON(w, http.StatusCreated, paymentIntent)</span>
}

// ConfirmPaymentIntent handles payment intent confirmation requests
func (h *StripeHandler) ConfirmPaymentIntent(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        paymentIntentID, ok := h.extractPathParameter(w, r, "id")
        if !ok </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">var req models.ConfirmPaymentIntentRequest
        if !h.parseAndValidateJSON(w, r, &amp;req) </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">paymentIntent, err := h.stripeService.ConfirmPaymentIntent(r.Context(), paymentIntentID, &amp;req)
        if err != nil </span><span class="cov8" title="1">{
                h.handleServiceError(w, err, "confirm payment intent", map[string]interface{}{
                        "payment_intent_id": paymentIntentID,
                        "payment_method_id": req.PaymentMethodID,
                })
                return
        }</span>

        <span class="cov8" title="1">h.writeJSON(w, http.StatusOK, paymentIntent)</span>
}

// Product handlers

// CreateProduct handles product creation requests
func (h *StripeHandler) CreateProduct(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var req models.CreateProductRequest

        if !h.parseAndValidateJSON(w, r, &amp;req) </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">product, err := h.stripeService.CreateProduct(r.Context(), &amp;req)
        if err != nil </span><span class="cov8" title="1">{
                h.handleServiceError(w, err, "create product", map[string]interface{}{
                        "name":   req.Name,
                        "active": req.Active,
                })
                return
        }</span>

        <span class="cov8" title="1">h.writeJSON(w, http.StatusCreated, product)</span>
}

// CreatePrice handles price creation requests
func (h *StripeHandler) CreatePrice(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var req models.CreatePriceRequest

        if !h.parseAndValidateJSON(w, r, &amp;req) </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">price, err := h.stripeService.CreatePrice(r.Context(), &amp;req)
        if err != nil </span><span class="cov8" title="1">{
                h.handleServiceError(w, err, "create price", map[string]interface{}{
                        "product_id":  req.ProductID,
                        "unit_amount": req.UnitAmount,
                        "currency":    req.Currency,
                })
                return
        }</span>

        <span class="cov8" title="1">h.writeJSON(w, http.StatusCreated, price)</span>
}

// Subscription handlers

// CreateSubscription handles subscription creation requests
func (h *StripeHandler) CreateSubscription(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var req models.CreateSubscriptionRequest

        if !h.parseAndValidateJSON(w, r, &amp;req) </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">subscription, err := h.stripeService.CreateSubscription(r.Context(), &amp;req)
        if err != nil </span><span class="cov8" title="1">{
                h.handleServiceError(w, err, "create subscription", map[string]interface{}{
                        "customer_id": req.CustomerID,
                        "price_id":    req.PriceID,
                })
                return
        }</span>

        <span class="cov8" title="1">h.writeJSON(w, http.StatusCreated, subscription)</span>
}

// CancelSubscription handles subscription cancellation requests
func (h *StripeHandler) CancelSubscription(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        subscriptionID, ok := h.extractPathParameter(w, r, "id")
        if !ok </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">subscription, err := h.stripeService.CancelSubscription(r.Context(), subscriptionID)
        if err != nil </span><span class="cov8" title="1">{
                h.handleServiceError(w, err, "cancel subscription", map[string]interface{}{
                        "subscription_id": subscriptionID,
                })
                return
        }</span>

        <span class="cov8" title="1">h.writeJSON(w, http.StatusOK, subscription)</span>
}

// Helper methods for response handling

func (h *StripeHandler) writeJSON(w http.ResponseWriter, status int, data interface{}) <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(status)

        if err := json.NewEncoder(w).Encode(data); err != nil </span><span class="cov0" title="0">{
                log.Printf("Error encoding JSON response: %v", err)
        }</span>
}

func (h *StripeHandler) writeError(w http.ResponseWriter, status int, message string) <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(status)

        errorResponse := map[string]string{"error": message}
        if err := json.NewEncoder(w).Encode(errorResponse); err != nil </span><span class="cov0" title="0">{
                log.Printf("Error encoding error response: %v", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package server

import (
        "log"
        "net/http"
        "time"

        "stripe-service/internal/handlers"

        "github.com/gorilla/mux"
)

type Server struct {
        router *mux.Router
}

func NewServer(stripeHandler *handlers.StripeHandler) *Server <span class="cov0" title="0">{
        s := &amp;Server{}
        s.setupRouter(stripeHandler)
        return s
}</span>

func (s *Server) Handler() http.Handler <span class="cov0" title="0">{
        return s.router
}</span>

func (s *Server) setupRouter(stripeHandler *handlers.StripeHandler) <span class="cov0" title="0">{
        router := mux.NewRouter()

        // Add middleware
        router.Use(s.loggingMiddleware)
        router.Use(s.corsMiddleware)

        // API routes
        api := router.PathPrefix("/api/v1").Subrouter()

        // Health check
        api.HandleFunc("/health", stripeHandler.HealthCheck).Methods("GET", "OPTIONS")

        // Customer routes
        api.HandleFunc("/customers", stripeHandler.CreateCustomer).Methods("POST")
        api.HandleFunc("/customers", stripeHandler.ListCustomers).Methods("GET")
        api.HandleFunc("/customers/{id}", stripeHandler.GetCustomer).Methods("GET")
        // Add OPTIONS support for all customer routes
        api.HandleFunc("/customers", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusOK)
        }</span>).Methods("OPTIONS")

        // Payment intent routes
        <span class="cov0" title="0">api.HandleFunc("/payment-intents", stripeHandler.CreatePaymentIntent).Methods("POST")
        api.HandleFunc("/payment-intents/{id}/confirm", stripeHandler.ConfirmPaymentIntent).Methods("POST")

        // Product routes
        api.HandleFunc("/products", stripeHandler.CreateProduct).Methods("POST")

        // Price routes
        api.HandleFunc("/prices", stripeHandler.CreatePrice).Methods("POST")

        // Subscription routes
        api.HandleFunc("/subscriptions", stripeHandler.CreateSubscription).Methods("POST")
        api.HandleFunc("/subscriptions/{id}", stripeHandler.CancelSubscription).Methods("DELETE")

        s.router = router</span>
}

// loggingMiddleware logs each HTTP request with structured information
func (s *Server) loggingMiddleware(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                start := time.Now()

                // Create a response writer wrapper to capture status code
                wrapper := &amp;responseWriterWrapper{ResponseWriter: w, statusCode: http.StatusOK}

                next.ServeHTTP(wrapper, r)

                duration := time.Since(start)

                // Structured logging with additional context
                log.Printf("HTTP Request - Method: %s, Path: %s, Status: %d, Duration: %v, UserAgent: %s, RemoteAddr: %s",
                        r.Method,
                        r.URL.Path,
                        wrapper.statusCode,
                        duration,
                        r.UserAgent(),
                        r.RemoteAddr,
                )
        }</span>)
}

// corsMiddleware adds CORS headers
func (s *Server) corsMiddleware(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Access-Control-Allow-Origin", "*")
                w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
                w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")

                if r.Method == "OPTIONS" </span><span class="cov0" title="0">{
                        w.WriteHeader(http.StatusOK)
                        return
                }</span>

                <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
        })
}

// responseWriterWrapper wraps http.ResponseWriter to capture status code
type responseWriterWrapper struct {
        http.ResponseWriter
        statusCode int
}

func (rw *responseWriterWrapper) WriteHeader(code int) <span class="cov0" title="0">{
        rw.statusCode = code
        rw.ResponseWriter.WriteHeader(code)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package service

import (
        "context"
        "fmt"
        "time"

        "stripe-service/config"
        "stripe-service/internal/models"

        "github.com/stripe/stripe-go/v76"
        "github.com/stripe/stripe-go/v76/client"
)

// Constants for default values
const (
        DefaultCustomerLimit = 10
        MaxCustomerLimit     = 100
)

// StripeService handles all Stripe operations
type StripeService struct {
        config *config.Config
        client *client.API
}

// NewStripeService creates a new Stripe service with its own client instance
func NewStripeService(cfg *config.Config) *StripeService <span class="cov8" title="1">{
        // Create a new Stripe client instance instead of using global state
        stripeClient := &amp;client.API{}
        stripeClient.Init(cfg.Stripe.SecretKey, nil)

        return &amp;StripeService{
                config: cfg,
                client: stripeClient,
        }
}</span>

// Customer operations

// CreateCustomer creates a new customer in Stripe
func (s *StripeService) CreateCustomer(ctx context.Context, req *models.CreateCustomerRequest) (*models.Customer, error) <span class="cov8" title="1">{
        params := &amp;stripe.CustomerParams{
                Email:       stripe.String(req.Email),
                Name:        stripe.String(req.Name),
                Description: stripe.String(req.Description),
        }

        // Set context for cancellation support
        params.Context = ctx

        if req.Phone != "" </span><span class="cov0" title="0">{
                params.Phone = stripe.String(req.Phone)
        }</span>

        <span class="cov8" title="1">if req.Metadata != nil </span><span class="cov0" title="0">{
                params.Metadata = req.Metadata
        }</span>

        <span class="cov8" title="1">stripeCustomer, err := s.client.Customers.New(params)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to create customer: %w", err)
        }</span>

        <span class="cov0" title="0">return s.convertStripeCustomer(stripeCustomer), nil</span>
}

// GetCustomer retrieves a customer by ID
func (s *StripeService) GetCustomer(ctx context.Context, customerID string) (*models.Customer, error) <span class="cov8" title="1">{
        params := &amp;stripe.CustomerParams{}
        params.Context = ctx

        stripeCustomer, err := s.client.Customers.Get(customerID, params)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to get customer: %w", err)
        }</span>

        <span class="cov0" title="0">return s.convertStripeCustomer(stripeCustomer), nil</span>
}

// ListCustomers lists customers with pagination
func (s *StripeService) ListCustomers(ctx context.Context, req *models.ListCustomersRequest) (*models.ListCustomersResponse, error) <span class="cov8" title="1">{
        params := &amp;stripe.CustomerListParams{}
        params.Context = ctx

        if req.Limit &gt; 0 </span><span class="cov0" title="0">{
                params.Limit = stripe.Int64(req.Limit)
        }</span> else<span class="cov8" title="1"> {
                params.Limit = stripe.Int64(DefaultCustomerLimit)
        }</span>

        <span class="cov8" title="1">if req.Cursor != "" </span><span class="cov0" title="0">{
                params.StartingAfter = stripe.String(req.Cursor)
        }</span>

        <span class="cov8" title="1">iter := s.client.Customers.List(params)
        var customers []models.Customer

        for iter.Next() </span><span class="cov0" title="0">{
                customers = append(customers, *s.convertStripeCustomer(iter.Customer()))
        }</span>

        <span class="cov8" title="1">if err := iter.Err(); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to list customers: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;models.ListCustomersResponse{
                Customers: customers,
                HasMore:   iter.Meta().HasMore,
        }, nil</span>
}

// Payment operations

// CreatePaymentIntent creates a new payment intent
func (s *StripeService) CreatePaymentIntent(ctx context.Context, req *models.CreatePaymentIntentRequest) (*models.PaymentIntent, error) <span class="cov0" title="0">{
        params := &amp;stripe.PaymentIntentParams{
                Amount:   stripe.Int64(req.Amount),
                Currency: stripe.String(req.Currency),
        }
        params.Context = ctx

        if req.CustomerID != "" </span><span class="cov0" title="0">{
                params.Customer = stripe.String(req.CustomerID)
        }</span>

        <span class="cov0" title="0">if req.Description != "" </span><span class="cov0" title="0">{
                params.Description = stripe.String(req.Description)
        }</span>

        <span class="cov0" title="0">if req.Metadata != nil </span><span class="cov0" title="0">{
                params.Metadata = req.Metadata
        }</span>

        <span class="cov0" title="0">if req.PaymentMethodID != "" </span><span class="cov0" title="0">{
                params.PaymentMethod = stripe.String(req.PaymentMethodID)
        }</span>

        <span class="cov0" title="0">if req.ConfirmationMethod != "" </span><span class="cov0" title="0">{
                params.ConfirmationMethod = stripe.String(req.ConfirmationMethod)
        }</span>

        <span class="cov0" title="0">stripePI, err := s.client.PaymentIntents.New(params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create payment intent: %w", err)
        }</span>

        <span class="cov0" title="0">return s.convertStripePaymentIntent(stripePI), nil</span>
}

// ConfirmPaymentIntent confirms a payment intent
func (s *StripeService) ConfirmPaymentIntent(ctx context.Context, paymentIntentID string, req *models.ConfirmPaymentIntentRequest) (*models.PaymentIntent, error) <span class="cov0" title="0">{
        params := &amp;stripe.PaymentIntentConfirmParams{}
        params.Context = ctx

        if req.PaymentMethodID != "" </span><span class="cov0" title="0">{
                params.PaymentMethod = stripe.String(req.PaymentMethodID)
        }</span>

        <span class="cov0" title="0">if req.ReturnURL != "" </span><span class="cov0" title="0">{
                params.ReturnURL = stripe.String(req.ReturnURL)
        }</span>

        <span class="cov0" title="0">stripePI, err := s.client.PaymentIntents.Confirm(paymentIntentID, params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to confirm payment intent: %w", err)
        }</span>

        <span class="cov0" title="0">return s.convertStripePaymentIntent(stripePI), nil</span>
}

// Product operations

// CreateProduct creates a new product
func (s *StripeService) CreateProduct(ctx context.Context, req *models.CreateProductRequest) (*models.Product, error) <span class="cov0" title="0">{
        params := &amp;stripe.ProductParams{
                Name:        stripe.String(req.Name),
                Description: stripe.String(req.Description),
                Active:      stripe.Bool(req.Active),
        }
        params.Context = ctx

        if req.Metadata != nil </span><span class="cov0" title="0">{
                params.Metadata = req.Metadata
        }</span>

        <span class="cov0" title="0">stripeProduct, err := s.client.Products.New(params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create product: %w", err)
        }</span>

        <span class="cov0" title="0">return s.convertStripeProduct(stripeProduct), nil</span>
}

// CreatePrice creates a new price
func (s *StripeService) CreatePrice(ctx context.Context, req *models.CreatePriceRequest) (*models.Price, error) <span class="cov0" title="0">{
        params := &amp;stripe.PriceParams{
                Product:    stripe.String(req.ProductID),
                UnitAmount: stripe.Int64(req.UnitAmount),
                Currency:   stripe.String(req.Currency),
                Active:     stripe.Bool(req.Active),
        }
        params.Context = ctx

        if req.Type == "recurring" &amp;&amp; req.RecurringInterval != "" </span><span class="cov0" title="0">{
                params.Recurring = &amp;stripe.PriceRecurringParams{
                        Interval: stripe.String(req.RecurringInterval),
                }
        }</span>

        <span class="cov0" title="0">if req.Metadata != nil </span><span class="cov0" title="0">{
                params.Metadata = req.Metadata
        }</span>

        <span class="cov0" title="0">stripePrice, err := s.client.Prices.New(params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create price: %w", err)
        }</span>

        <span class="cov0" title="0">return s.convertStripePrice(stripePrice), nil</span>
}

// Subscription operations

// CreateSubscription creates a new subscription
func (s *StripeService) CreateSubscription(ctx context.Context, req *models.CreateSubscriptionRequest) (*models.Subscription, error) <span class="cov0" title="0">{
        params := &amp;stripe.SubscriptionParams{
                Customer: stripe.String(req.CustomerID),
                Items: []*stripe.SubscriptionItemsParams{
                        {
                                Price: stripe.String(req.PriceID),
                        },
                },
        }
        params.Context = ctx

        if req.Metadata != nil </span><span class="cov0" title="0">{
                params.Metadata = req.Metadata
        }</span>

        <span class="cov0" title="0">stripeSub, err := s.client.Subscriptions.New(params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create subscription: %w", err)
        }</span>

        <span class="cov0" title="0">return s.convertStripeSubscription(stripeSub), nil</span>
}

// CancelSubscription cancels a subscription
func (s *StripeService) CancelSubscription(ctx context.Context, subscriptionID string) (*models.Subscription, error) <span class="cov0" title="0">{
        params := &amp;stripe.SubscriptionCancelParams{}
        params.Context = ctx

        stripeSub, err := s.client.Subscriptions.Cancel(subscriptionID, params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to cancel subscription: %w", err)
        }</span>

        <span class="cov0" title="0">return s.convertStripeSubscription(stripeSub), nil</span>
}

// Helper methods to convert Stripe objects to internal models

// StripeCustomer interface for testing
type StripeCustomer interface {
        GetID() string
        GetEmail() string
        GetName() string
        GetPhone() string
        GetDescription() string
        GetMetadata() map[string]string
        GetCreated() int64
}

// Adapter for real Stripe customer
type stripeCustomerAdapter struct {
        customer *stripe.Customer
}

func (a *stripeCustomerAdapter) GetID() string                  <span class="cov0" title="0">{ return a.customer.ID }</span>
func (a *stripeCustomerAdapter) GetEmail() string               <span class="cov0" title="0">{ return a.customer.Email }</span>
func (a *stripeCustomerAdapter) GetName() string                <span class="cov0" title="0">{ return a.customer.Name }</span>
func (a *stripeCustomerAdapter) GetPhone() string               <span class="cov0" title="0">{ return a.customer.Phone }</span>
func (a *stripeCustomerAdapter) GetDescription() string         <span class="cov0" title="0">{ return a.customer.Description }</span>
func (a *stripeCustomerAdapter) GetMetadata() map[string]string <span class="cov0" title="0">{ return a.customer.Metadata }</span>
func (a *stripeCustomerAdapter) GetCreated() int64              <span class="cov0" title="0">{ return a.customer.Created }</span>

func (s *StripeService) convertStripeCustomer(stripeCustomer *stripe.Customer) *models.Customer <span class="cov0" title="0">{
        adapter := &amp;stripeCustomerAdapter{customer: stripeCustomer}
        return s.convertStripeCustomerInterface(adapter)
}</span>

func (s *StripeService) convertStripeCustomerInterface(stripeCustomer StripeCustomer) *models.Customer <span class="cov8" title="1">{
        // Use Stripe's created timestamp for both created and updated
        createdAt := time.Unix(stripeCustomer.GetCreated(), 0)

        return &amp;models.Customer{
                ID:          stripeCustomer.GetID(),
                Email:       stripeCustomer.GetEmail(),
                Name:        stripeCustomer.GetName(),
                Phone:       stripeCustomer.GetPhone(),
                Description: stripeCustomer.GetDescription(),
                Metadata:    stripeCustomer.GetMetadata(),
                CreatedAt:   createdAt,
                UpdatedAt:   createdAt, // Stripe doesn't provide separate updated_at
        }
}</span>

func (s *StripeService) convertStripePaymentIntent(stripePI *stripe.PaymentIntent) *models.PaymentIntent <span class="cov0" title="0">{
        customerID := ""
        if stripePI.Customer != nil </span><span class="cov0" title="0">{
                customerID = stripePI.Customer.ID
        }</span>

        <span class="cov0" title="0">createdAt := time.Unix(stripePI.Created, 0)

        return &amp;models.PaymentIntent{
                ID:           stripePI.ID,
                Amount:       stripePI.Amount,
                Currency:     string(stripePI.Currency),
                Status:       string(stripePI.Status),
                CustomerID:   customerID,
                Description:  stripePI.Description,
                Metadata:     stripePI.Metadata,
                ClientSecret: stripePI.ClientSecret,
                CreatedAt:    createdAt,
                UpdatedAt:    createdAt,
        }</span>
}

func (s *StripeService) convertStripeProduct(stripeProduct *stripe.Product) *models.Product <span class="cov0" title="0">{
        createdAt := time.Unix(stripeProduct.Created, 0)
        updatedAt := createdAt
        if stripeProduct.Updated &gt; 0 </span><span class="cov0" title="0">{
                updatedAt = time.Unix(stripeProduct.Updated, 0)
        }</span>

        <span class="cov0" title="0">return &amp;models.Product{
                ID:          stripeProduct.ID,
                Name:        stripeProduct.Name,
                Description: stripeProduct.Description,
                Active:      stripeProduct.Active,
                Metadata:    stripeProduct.Metadata,
                CreatedAt:   createdAt,
                UpdatedAt:   updatedAt,
        }</span>
}

func (s *StripeService) convertStripePrice(stripePrice *stripe.Price) *models.Price <span class="cov0" title="0">{
        createdAt := time.Unix(stripePrice.Created, 0)

        priceType := "one_time"
        recurringInterval := ""

        if stripePrice.Recurring != nil </span><span class="cov0" title="0">{
                priceType = "recurring"
                recurringInterval = string(stripePrice.Recurring.Interval)
        }</span>

        <span class="cov0" title="0">return &amp;models.Price{
                ID:                stripePrice.ID,
                ProductID:         stripePrice.Product.ID,
                UnitAmount:        stripePrice.UnitAmount,
                Currency:          string(stripePrice.Currency),
                Type:              priceType,
                RecurringInterval: recurringInterval,
                Active:            stripePrice.Active,
                Metadata:          stripePrice.Metadata,
                CreatedAt:         createdAt,
                UpdatedAt:         createdAt,
        }</span>
}

func (s *StripeService) convertStripeSubscription(stripeSub *stripe.Subscription) *models.Subscription <span class="cov0" title="0">{
        createdAt := time.Unix(stripeSub.Created, 0)

        return &amp;models.Subscription{
                ID:                 stripeSub.ID,
                CustomerID:         stripeSub.Customer.ID,
                PriceID:            stripeSub.Items.Data[0].Price.ID,
                Status:             string(stripeSub.Status),
                CurrentPeriodStart: time.Unix(stripeSub.CurrentPeriodStart, 0),
                CurrentPeriodEnd:   time.Unix(stripeSub.CurrentPeriodEnd, 0),
                Metadata:           stripeSub.Metadata,
                CreatedAt:          createdAt,
                UpdatedAt:          createdAt,
        }
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package main

import (
        "context"
        "fmt"
        "log"
        "net/http"
        "os"
        "os/signal"
        "syscall"
        "time"

        "stripe-service/config"
        "stripe-service/internal/handlers"
        "stripe-service/internal/server"
        "stripe-service/internal/service"
)

func main() <span class="cov0" title="0">{
        // Load configuration
        cfg := config.Load()

        // Validate required configuration
        if cfg.Stripe.SecretKey == "" </span><span class="cov0" title="0">{
                log.Fatal("STRIPE_SECRET_KEY environment variable is required")
        }</span>

        // Initialize services
        <span class="cov0" title="0">stripeService := service.NewStripeService(cfg)

        // Initialize handlers
        stripeHandler := handlers.NewStripeHandler(stripeService)

        // Initialize server
        srv := server.NewServer(stripeHandler)

        // Setup HTTP server
        httpServer := &amp;http.Server{
                Addr:         fmt.Sprintf("%s:%d", cfg.Server.Host, cfg.Server.Port),
                Handler:      srv.Handler(),
                ReadTimeout:  15 * time.Second,
                WriteTimeout: 15 * time.Second,
                IdleTimeout:  60 * time.Second,
        }

        // Start server in a goroutine
        go func() </span><span class="cov0" title="0">{
                log.Printf("üöÄ Starting Stripe Service on %s:%d", cfg.Server.Host, cfg.Server.Port)
                if err := httpServer.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        log.Fatalf("Server failed to start: %v", err)
                }</span>
        }()

        // Wait for interrupt signal to gracefully shutdown the server
        <span class="cov0" title="0">quit := make(chan os.Signal, 1)
        signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
        &lt;-quit

        log.Println("üõë Shutting down server...")

        // Graceful shutdown with timeout
        ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()

        if err := httpServer.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Server forced to shutdown: %v", err)
        }</span>

        <span class="cov0" title="0">log.Println("‚úÖ Server exited gracefully")</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package main

import (
        "bytes"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "time"
)

const baseURL = "http://localhost:8080/api/v1"

type TestData struct {
        CustomerID      string
        ProductID       string
        PriceID         string
        PaymentIntentID string
        SubscriptionID  string
}

func main() <span class="cov0" title="0">{
        fmt.Println("üöÄ Creating test data for Stripe Service...")

        // Check if service is running
        if !isServiceRunning() </span><span class="cov0" title="0">{
                fmt.Println("‚ùå Service is not running. Please start the service first with: go run main.go")
                return
        }</span>

        <span class="cov0" title="0">var testData TestData

        // 1. Create a test customer
        fmt.Println("\n1. Creating test customer...")
        customerID, err := createTestCustomer()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("‚ùå Failed to create customer: %v\n", err)
                return
        }</span>
        <span class="cov0" title="0">testData.CustomerID = customerID
        fmt.Printf("‚úÖ Created customer: %s\n", customerID)

        // 2. Create a test product
        fmt.Println("\n2. Creating test product...")
        productID, err := createTestProduct()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("‚ùå Failed to create product: %v\n", err)
                return
        }</span>
        <span class="cov0" title="0">testData.ProductID = productID
        fmt.Printf("‚úÖ Created product: %s\n", productID)

        // 3. Create a test price
        fmt.Println("\n3. Creating test price...")
        priceID, err := createTestPrice(productID)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("‚ùå Failed to create price: %v\n", err)
                return
        }</span>
        <span class="cov0" title="0">testData.PriceID = priceID
        fmt.Printf("‚úÖ Created price: %s\n", priceID)

        // 4. Create a test payment intent
        fmt.Println("\n4. Creating test payment intent...")
        paymentIntentID, err := createTestPaymentIntent(customerID)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("‚ùå Failed to create payment intent: %v\n", err)
                return
        }</span>
        <span class="cov0" title="0">testData.PaymentIntentID = paymentIntentID
        fmt.Printf("‚úÖ Created payment intent: %s\n", paymentIntentID)

        // 5. Create a test subscription
        fmt.Println("\n5. Creating test subscription...")
        subscriptionID, err := createTestSubscription(customerID, priceID)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("‚ùå Failed to create subscription: %v\n", err)
                return
        }</span>
        <span class="cov0" title="0">testData.SubscriptionID = subscriptionID
        fmt.Printf("‚úÖ Created subscription: %s\n", subscriptionID)

        // 6. List customers to verify
        fmt.Println("\n6. Listing customers...")
        if err := listCustomers(); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("‚ùå Failed to list customers: %v\n", err)
        }</span>

        // Print summary
        <span class="cov0" title="0">fmt.Println("\nüéâ Test data created successfully!")
        fmt.Println("üìä Summary:")
        fmt.Printf("   Customer ID: %s\n", testData.CustomerID)
        fmt.Printf("   Product ID: %s\n", testData.ProductID)
        fmt.Printf("   Price ID: %s\n", testData.PriceID)
        fmt.Printf("   Payment Intent ID: %s\n", testData.PaymentIntentID)
        fmt.Printf("   Subscription ID: %s\n", testData.SubscriptionID)

        fmt.Println("\nüí° You can now test the API endpoints with this data!")
        fmt.Println("   Example: curl http://localhost:8080/api/v1/customers/" + testData.CustomerID)</span>
}

func isServiceRunning() bool <span class="cov0" title="0">{
        resp, err := http.Get(baseURL + "/health")
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()
        return resp.StatusCode == http.StatusOK</span>
}

func createTestCustomer() (string, error) <span class="cov0" title="0">{
        payload := map[string]interface{}{
                "email":       "test@example.com",
                "name":        "Test Customer",
                "phone":       "+1234567890",
                "description": "Test customer created by script",
                "metadata": map[string]string{
                        "source": "test_script",
                        "env":    "development",
                },
        }

        resp, err := makeRequest("POST", "/customers", payload)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">var customer map[string]interface{}
        if err := json.Unmarshal(resp, &amp;customer); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return customer["id"].(string), nil</span>
}

func createTestProduct() (string, error) <span class="cov0" title="0">{
        payload := map[string]interface{}{
                "name":        "Test Product",
                "description": "A test product created by script",
                "active":      true,
                "metadata": map[string]string{
                        "category": "test",
                        "source":   "test_script",
                },
        }

        resp, err := makeRequest("POST", "/products", payload)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">var product map[string]interface{}
        if err := json.Unmarshal(resp, &amp;product); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return product["id"].(string), nil</span>
}

func createTestPrice(productID string) (string, error) <span class="cov0" title="0">{
        payload := map[string]interface{}{
                "product_id":  productID,
                "unit_amount": 999, // $9.99
                "currency":    "usd",
                "type":        "one_time",
                "active":      true,
                "metadata": map[string]string{
                        "source": "test_script",
                },
        }

        resp, err := makeRequest("POST", "/prices", payload)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">var price map[string]interface{}
        if err := json.Unmarshal(resp, &amp;price); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return price["id"].(string), nil</span>
}

func createTestPaymentIntent(customerID string) (string, error) <span class="cov0" title="0">{
        payload := map[string]interface{}{
                "amount":      2000, // $20.00
                "currency":    "usd",
                "customer_id": customerID,
                "description": "Test payment intent",
                "metadata": map[string]string{
                        "source": "test_script",
                },
        }

        resp, err := makeRequest("POST", "/payment-intents", payload)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">var paymentIntent map[string]interface{}
        if err := json.Unmarshal(resp, &amp;paymentIntent); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return paymentIntent["id"].(string), nil</span>
}

func createTestSubscription(customerID, priceID string) (string, error) <span class="cov0" title="0">{
        payload := map[string]interface{}{
                "customer_id": customerID,
                "price_id":    priceID,
                "metadata": map[string]string{
                        "source": "test_script",
                        "plan":   "test_plan",
                },
        }

        resp, err := makeRequest("POST", "/subscriptions", payload)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">var subscription map[string]interface{}
        if err := json.Unmarshal(resp, &amp;subscription); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return subscription["id"].(string), nil</span>
}

func listCustomers() error <span class="cov0" title="0">{
        resp, err := makeRequest("GET", "/customers", nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var response map[string]interface{}
        if err := json.Unmarshal(resp, &amp;response); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">customers := response["customers"].([]interface{})
        fmt.Printf("‚úÖ Found %d customers\n", len(customers))

        for i, customer := range customers </span><span class="cov0" title="0">{
                c := customer.(map[string]interface{})
                fmt.Printf("   %d. %s (%s) - %s\n", i+1, c["name"], c["id"], c["email"])
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func makeRequest(method, endpoint string, payload interface{}) ([]byte, error) <span class="cov0" title="0">{
        var body io.Reader

        if payload != nil </span><span class="cov0" title="0">{
                jsonData, err := json.Marshal(payload)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">body = bytes.NewBuffer(jsonData)</span>
        }

        <span class="cov0" title="0">req, err := http.NewRequest(method, baseURL+endpoint, body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if payload != nil </span><span class="cov0" title="0">{
                req.Header.Set("Content-Type", "application/json")
        }</span>

        <span class="cov0" title="0">client := &amp;http.Client{Timeout: 30 * time.Second}
        resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        respBody, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if resp.StatusCode &gt;= 400 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("HTTP %d: %s", resp.StatusCode, string(respBody))
        }</span>

        <span class="cov0" title="0">return respBody, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
